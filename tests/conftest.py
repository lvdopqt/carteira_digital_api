import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session
from sqlalchemy.pool import StaticPool
from typing import Generator, Any
import os

# Define the URL for the in-memory SQLite database
TEST_DATABASE_URL = "sqlite:///:memory:"

# --- Set the DATABASE_URL environment variable globally for tests ---
# This attempts to ensure that when app.db.session is imported,
# it uses this URL for the engine.
os.environ['DATABASE_URL'] = TEST_DATABASE_URL
# --- End Global Override ---


# Import the application's main instance
# This import should now use the globally set DATABASE_URL
from app.main import app
# Import the Base metadata for table creation
from app.db.base_class import Base
# Import ORM models to ensure they are registered with Base
from app.models.user import User
from app.models.document import Document
# Import hashing function for creating test users
from app.core.hashing import get_password_hash

from app.models.user import User as UserModel

# Import mock data if used in services (like transport)
from app.services.transport import mock_balances

# Import the actual get_db dependency from the application
from app.db.session import get_db


@pytest.fixture(scope="session")
def db_engine():
    """
    Fixture for the test database engine (session scope).
    Creates an engine using the globally set DATABASE_URL and creates tables.
    Runs once per test session.
    """
    # The engine should now be created using the TEST_DATABASE_URL
    engine = create_engine(
        os.environ['DATABASE_URL'], # Use the environment variable
        connect_args={"check_same_thread": False},
        poolclass=StaticPool,
    )
    # Create all tables defined in Base.metadata on the test database
    # This runs once per test session.
    Base.metadata.create_all(bind=engine)
    yield engine
    # Drop all tables after the session scope ends (optional for in-memory SQLite)
    # Base.metadata.drop_all(bind=engine)


@pytest.fixture(scope="function")
def db(db_engine) -> Generator[Session, Any, None]:
    """
    Fixture for the test database session with transactional rollback (function scope).
    Overrides the application's get_db dependency for each test function.
    """
    # Create a connection from the engine
    connection = db_engine.connect()
    # Begin a transaction on the connection
    transaction = connection.begin()
    # Create a session bound to the connection
    session = Session(bind=connection)

    # Override the application's get_db dependency to return this test session
    # This ensures that any part of the application requesting a DB session
    # via Depends(get_db) receives the test session.
    app.dependency_overrides[get_db] = lambda: session

    yield session # Provide the test session to tests that explicitly request the 'db' fixture

    # Rollback the transaction and close the session after each test function
    # This cleans up the database state for the next test
    transaction.rollback()
    session.close()
    # Dependency overrides are cleared in the 'client' fixture's teardown


@pytest.fixture(scope="function")
def test_user(db: Session):
    """
    Fixture to create a test user in the DB for use in tests (function scope).
    Relies on the 'db' fixture's transactional rollback for cleanup.
    """
    email = "testuser@example.com"
    password = "testpassword"
    hashed_password = get_password_hash(password)

    user = User(email=email, hashed_password=hashed_password, is_active=True, is_superuser=False, full_name="Test User")
    db.add(user)
    # No need to commit here, the 'db' fixture handles the transaction and rollback
    # Use flush to ensure the object is in the session and gets an ID
    db.flush()
    db.refresh(user) # Refresh to get the ID generated by the DB

    yield user


@pytest.fixture(scope="module")
def client() -> TestClient:
    """
    Fixture for the FastAPI test client (module scope).
    Relies on the global DATABASE_URL override in conftest.py.
    """
    # The TestClient loads the application, which should now use the
    # SQLite engine configured by the global DATABASE_URL override.
    with TestClient(app) as c:
        yield c
    # Clear dependency overrides after the module's tests are done
    # This is important to prevent test overrides from affecting other modules
    app.dependency_overrides.clear()


@pytest.fixture(scope="function")
def user_auth_token(client: TestClient, test_user: UserModel):
    """
    Fixture to get an access token for the test user (function scope).
    Depends on 'client' and 'test_user'.
    """
    login_data = {"email": test_user.email, "password": "testpassword"}

    response = client.post("/api/v1/auth/login", json=login_data)

    assert response.status_code == 200, f"Expected status 200, but got {response.status_code}. Response: {response.text}"

    token_data = response.json()
    assert "access_token" in token_data
    assert token_data["token_type"] == "bearer"

    return f"Bearer {token_data['access_token']}"

@pytest.fixture(scope="function")
def reset_transport_balances():
    """
    Fixture to reset the in-memory mock_balances before each test (function scope).
    """
    mock_balances.clear()
    yield
